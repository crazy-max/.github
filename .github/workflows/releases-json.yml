name: releases-json

# https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#permissions
permissions:
  contents: read

on:
  workflow_call:
    inputs:
      repository:
        required: true
        type: string
      artifact_name:
        required: false
        type: string
        default: 'releases-json'
      filename:
        required: false
        type: string
        default: 'releases.json'
      pin_latest:
        required: false
        type: string
      tag_patterns:
        required: false
        type: string

jobs:
  generate:
    runs-on: ubuntu-latest
    outputs:
      releases: ${{ steps.generate.outputs.releases }}
    steps:
      -
        name: Install npm deps
        uses: actions/github-script@v8
        with:
          script: |
            await core.group(`Install npm deps`, async () => {
              await exec.exec('npm', ['install', 'semver']);
            });
      -
        name: Generate
        id: generate
        uses: actions/github-script@v8
        env:
          INPUT_REPOSITORY: ${{ inputs.repository }}
          INPUT_FILENAME: ${{ inputs.filename }}
          INPUT_PIN_LATEST: ${{ inputs.pin_latest }}
          INPUT_TAG_PATTERNS: ${{ inputs.tag_patterns }}
        with:
          retries: 3
          script: |
            const fs = require('fs');
            const semver = require('semver');

            function extractVersion(tag, patterns) {
              if (patterns.length === 0) {
                return tag;
              }
              for (const pattern of patterns) {
                const match = tag.match(new RegExp(pattern));
                if (match && match[1]) {
                  return match[1];
                }
              }
              return undefined;
            }

            const inpRepository = core.getInput('repository');
            const inpFilename = core.getInput('filename');
            const inpPinLatest = core.getInput('pin_latest');
            const inpTagPatterns = core.getMultilineInput('tag_patterns');

            let res = {};
            const [owner, repo] = inpRepository.split('/');
            core.info(`Fetching releases for ${owner}/${repo}`);

            const latestRelease = await github.rest.repos.getLatestRelease({
              owner,
              repo,
            });
            res['latest'] = {
              id: latestRelease.data.id,
              tag_name: latestRelease.data.tag_name,
              html_url: latestRelease.data.html_url,
              assets: latestRelease.data.assets.map(asset => asset.browser_download_url).sort(),
            };
            const latestVersion = extractVersion(res['latest'].tag_name, inpTagPatterns);
            if (!latestVersion) {
              throw new Error(`Latest release tag ${res['latest'].tag_name} does not match any provided pattern`);
            }

            const releases = await github.paginate(github.rest.repos.listReleases.endpoint.merge({
              owner,
              repo,
            }));
            for (const release of releases) {
              if (release.draft) {
                continue;
              }
              const version = extractVersion(release.tag_name, inpTagPatterns);
              if (!version) {
                continue;
              }
              if (!res['edge'] && release.prerelease) {
                if (semver.gt(version, latestVersion)) {
                  res['edge'] = {
                    id: release.id,
                    tag_name: release.tag_name,
                    html_url: release.html_url,
                    assets: release.assets.map(asset => asset.browser_download_url).sort(),
                  };
                } else {
                  res['edge'] = res['latest'];
                }
              }
              if (inpPinLatest && version === inpPinLatest) {
                res['latest'] = {
                  id: release.id,
                  tag_name: release.tag_name,
                  html_url: release.html_url,
                  assets: release.assets.map(asset => asset.browser_download_url).sort(),
                };
              }
              res[version] = {
                id: release.id,
                tag_name: release.tag_name,
                html_url: release.html_url,
                assets: release.assets.map(asset => asset.browser_download_url).sort(),
              };
            }

            await fs.writeFileSync(inpFilename, JSON.stringify(res, null, 2));
      -
        name: Check file
        run: |
          jq . ${{ inputs.filename }}
      -
        name: Upload artifact
        uses: actions/upload-artifact@v5
        with:
          name: ${{ inputs.artifact_name }}
          path: ${{ inputs.filename }}
          if-no-files-found: error
